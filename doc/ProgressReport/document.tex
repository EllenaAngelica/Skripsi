\documentclass[a4paper,twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[bahasa]{babel}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{float}
\usepackage[cm]{fullpage}
\pagestyle{myheadings}
\usepackage{etoolbox}
\usepackage{setspace} 
\usepackage{lipsum}
\usepackage{url} 
\usepackage{listings}
\setlength{\headsep}{30pt}
\usepackage[inner=2cm,outer=2.5cm,top=2.5cm,bottom=2cm]{geometry} %margin
% \pagestyle{empty}

\makeatletter
\renewcommand{\@maketitle} {\begin{center} {\LARGE \textbf{ \textsc{\@title}} \par} \bigskip {\large \textbf{\textsc{\@author}} }\end{center} }
\renewcommand{\thispagestyle}[1]{}
\markright{\textbf{\textsc{Laporan Perkembangan Pengerjaan Skripsi\textemdash Sem. Ganjil 2018/2019}}}

\onehalfspacing
 
\begin{document}

\title{\@judultopik}
\author{\nama \textendash \@npm} 

%ISILAH DATA BERIKUT INI:
\newcommand{\nama}{Ellena Angelica}
\newcommand{\@npm}{2015730029}
\newcommand{\tanggal}{15/11/2018} %Tanggal pembuatan dokumen
\newcommand{\@judultopik}{Kolektor Pengumuman Informatika} % Judul/topik anda
\newcommand{\kodetopik}{PAN4504}
\newcommand{\jumpemb}{1} % Jumlah pembimbing, 1 atau 2
\newcommand{\pembA}{Pascal Alfadian Nugroho}
\newcommand{\pembB}{-}
\newcommand{\semesterPertama}{45 - Ganjil 18/19} % semester pertama kali topik diambil, angka 1 dimulai dari sem Ganjil 96/97
\newcommand{\lamaSkripsi}{1} % Jumlah semester untuk mengerjakan skripsi s.d. dokumen ini dibuat
\newcommand{\kulPertama}{Skripsi 1} % Kuliah dimana topik ini diambil pertama kali
\newcommand{\tipePR}{B} % tipe progress report :
% A : dokumen pendukung untuk pengambilan ke-2 di Skripsi 1
% B : dokumen untuk reviewer pada presentasi dan review Skripsi 1
% C : dokumen pendukung untuk pengambilan ke-2 di Skripsi 2

% Dokumen hasil template ini harus dicetak bolak-balik !!!!

\maketitle

\pagenumbering{arabic}

\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  frame=single,
  breaklines=true,
  showlines=true,
}

\section{Data Skripsi} %TIDAK PERLU MENGUBAH BAGIAN INI !!!
Pembimbing utama/tunggal: {\bf \pembA}\\
Pembimbing pendamping: {\bf \pembB}\\
Kode Topik : {\bf \kodetopik}\\
Topik ini sudah dikerjakan selama : {\bf \lamaSkripsi} semester\\
Pengambilan pertama kali topik ini pada : Semester {\bf \semesterPertama} \\
Pengambilan pertama kali topik ini di kuliah : {\bf \kulPertama} \\
Tipe Laporan : {\bf \tipePR} -
\ifdefstring{\tipePR}{A}{
			Dokumen pendukung untuk {\BF pengambilan ke-2 di Skripsi 1} }
		{
		\ifdefstring{\tipePR}{B} {
				Dokumen untuk reviewer pada presentasi dan {\bf review Skripsi 1}}
			{	Dokumen pendukung untuk {\bf pengambilan ke-2 di Skripsi 2}}
		}
		
\section{Latar Belakang}
Pengumuman di jurusan Teknik Informatika UNPAR pada umumnya dilakukan lewat email. Pengumuman lewat email ini praktis karena tidak perlu menunggu email sampai ke tujuan dan dijamin sampai ke tujuan. Selain itu, konten yang disampaikan melalui email fleksibel. Konten tidak harus hanya tulisan tapi dapat ditambah dengan lampiran, dapat diubah gaya tulisannya, dan lain-lain. Namun, email kurang terorganisir dengan baik. Email yang masuk dapat tercampur dengan email lain sehingga mahasiswa kesulitan mencari email yang penting. Dampaknya, pengumuman-pengumuman penting dapat tidak terbaca secara tidak sengaja.

Pada skripsi ini, akan dibuat solusi masalah tadi dengan membangun suatu fitur. Fitur ini akan menangkap email-email pengumuman yang masuk ke sebuah email khusus untuk menangkap pengumuman. Pertama, email yang masuk ke email khusus akan diperiksa pengirimnya. Apabila pengirim adalah email yang terdaftar sebagai email yang berhak melakukan pengumuman, maka email tersebut adalah email pengumuman. Setelah itu, email tersebut akan dibuatkan permanent link dan disisipkan pada basis data. Lalu, mahasiswa akan menerima permanent link tersebut melalui notifikasi dari akun Line@. Line@ adalah layanan dari Line Corporation yang memudahkan pemilik bisnis atau organisasi menyampaikan pesan kepada pengikutnya melalui aplikasi pengirim pesan LINE.

Fitur ini akan dibangun sebagai fitur tambahan pada BlueTape, sebuah website milik jurusan teknik Informatika Unpar. Pembangunan fitur ini membutuhkan modifikasi BlueTape sehingga dapat dijalankan di Heroku. Heroku adalah \textit{cloud platform} yang memungkinkan \textit{developer} untuk membangun, menjalankan, dan mengoperasikan aplikasi pada \textit{cloud}. Selain itu, fitur ini membutuhkan beberapa fitur dari PHP IMAP dan layanan pengirim pesan LINE.

\section{Rumusan Masalah}
\begin{itemize}
\item Bagaimana cara memodifikasi BlueTape agar fitur kolektor pengumuman dapat diimplementasikan dengan bantuan Heroku dan PostgreSQL ?
\item Bagaimana cara mengimplementasikan kolektor pengumuman pada BlueTape ?
\end{itemize}

\section{Tujuan}
\begin{itemize}
\item Melakukan perawatan pada BlueTape agar fitur kolektor pengumuman dapat diimplementasikan dengan bantuan Heroku dan PostgreSQL
\item Mengimplementasikan fitur kolektor pengumuman pada BlueTape
\end{itemize}

\section{Detail Perkembangan Pengerjaan Skripsi}
Detail bagian pekerjaan skripsi sesuai dengan rencana kerja/laporan perkembangan terakhir :
\begin{enumerate}
	\item \textbf{Melakukan studi literatur tentang Heroku, Gmail, PHP IMAP, dan LINE}\\
	{\bf Status :} Ada sejak rencana kerja skripsi, kecuali PHP IMAP\\
	{\bf Hasil :}
	Studi literatur tentang Heroku, Gmail, PHP IMAP, dan LINE telah selesai dilakukan. Hasil dari studi literatur :
	\begin{enumerate}
		\item \textbf{Heroku}
		
		Heroku adalah \textit{cloud platform} yang memungkinkan \textit{developer} untuk membangun, menjalankan, dan mengoperasikan aplikasi pada \textit{cloud}. Heroku mendukung beberapa bahasa pemrograman, meliputi : Ruby, Node.js, Java, Python, Clojure, Scala, Go, dan PHP.
		\\
		\\
		\textbf{Arsitektur Heroku}
		
			Arsitektur Heroku terdiri dari :
			\begin{itemize}
				\item \textbf{Aplikasi}
				
				Heroku mendefinisikan aplikasi sebagai gabungan dari \textit{source code} yang ditulis di dalam salah satu bahasa yang didukung Heroku, deskripsi \textit{dependency} yang dipakai, dan Procfile.
		
				\item \textbf{\textit{Dependency}}
		
				\textit{Developer} perlu mendeskripsikan \textit{dependency} tambahan yang diperlukan agar aplikasi dapat dibangun dan dijalankan. Aturan penulisan deskripsi \textit{dependency} berbeda-beda untuk tiap bahasa. Contoh : pada aplikasi dengan bahasa Node.js, deskripsi \textit{dependency} ditulis di dokumen \texttt{package.json}.
		
				\item \textbf{Procfile}
		
				\textit{Developer} perlu memberitahu Heroku bagian aplikasi yang dapat dijalankan. Jika \textit{developer} menggunakan framework yang sudah ada, Heroku dapat mencari tahu. Contoh : pada aplikasi dengan bahasa Node.js, Heroku dapat mengetahui bagian aplikasi yang dijalankan pada bagian \texttt{main} di dalam \texttt{package.json}. Untuk aplikasi lain, \textit{developer} mungkin perlu menyatakan apa yang harus dieksekusi secara eksplisit. Caranya dengan menyertakan sebuah dokumen teks bernama Procfile. 

Dokumen Procfile tidak memiliki ekstensi dokumen, seperti \texttt{.txt}, \texttt{.docx}, \texttt{.jpg} dan lain-lain. Apabila Procfile diberi ekstensi dokumen (contoh : Procfile.txt), maka Procfile tersebut tidak sah. Selain itu, Procfile harus diletakkan di direktori \texttt{root}. Jika diletakkan di tempat lain, Procfile tidak akan berfungsi sebagaimana mestinya.

Isi dari Procfile adalah satu atau lebih baris yang menyatakan \textit{process type}. Format penulisan tiap baris Procfile adalah : 
\begin{lstlisting}

	<process type>: <command>

\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{<process type>} : nama perintah yang mengandung huruf dan angka. Contoh : \texttt{web}, \texttt{worker}, \texttt{urgentworker}, \texttt{clock}, dan lain-lain. Untuk aplikasi sederhana, \textit{developer} cukup menuliskan \textit{process type} \texttt{web} saja.
\item \texttt{<command>} : perintah yang setiap dyno dari \textit{process type} tersebut harus jalankan pada saat startup.
\end{itemize}
 
Contoh isi Procfile :
\begin{lstlisting}

	web: java -jar lib/foobar.jar \textdollar PORT

\end{lstlisting}

Pada contoh, \texttt{web} merupakan \texttt{<process type>}, sedangkan \texttt{web: java -jar lib/foobar.jar \textdollar PORT} adalah perintah yang harus dijalankan agar \textit{process type} tersebut berjalan. Perintah tersebut berfungsi untuk menyalakan web server.

Procfile tidak wajib dibuat untuk sebagian besar bahasa pemrograman yang didukung Heroku. Heroku akan secara otomatis mendeteksi bahasa yang digunakan, dan membuat \textit{process type} \texttt{web} untuk menjalankan server aplikasi. Apabila aplikasi menggunakan \texttt{heroku.yml} sebagai \textit{build manifest}, Procfile juga tidak diwajibkan. Perintah yang disebutkan di bagian \texttt{run} pada \texttt{heroku.yml} harus mengikuti format yang sama dengan format Procfile (kecuali \textit{process type} release).
		
				\item \textbf{\textit{Process Type}}
				
				Ada tiga kelompok \textit{process type} : 
\begin{itemize}
\item \textit{process type} \texttt{web}
\item \textit{process type} \texttt{worker} : \textit{process type} apapun selain \texttt{web}
\item \textit{process type} \texttt{singleton} : \textit{process type} yang bersifat sementara dan dapat berjalan terpisah
\end{itemize}

Di antara beragam \textit{process type}, ada dua \textit{process type} spesial : \textit{process type} \texttt{web} dan \texttt{release}. \textit{Process type} \texttt{web} adalah satu-satunya \textit{process type} yang dapat menerima arus HTTP eksternal dari router Heroku. Jika sebuah aplikasi melibatkan web server, \textit{developer} harus menyatakannya sebagai proses \texttt{web}. \textit{Process type} \texttt{release} adalah \textit{process type} yang digunakan untuk menyebutkan perintah yang dijalankan selama fase release.

\begin{figure}[H]
	\centering  
	\includegraphics[scale=0.4]{Gambar/process-type-dyno-relationship.jpg}  
	\caption[Diagram hubungan antara tipe proses dan dyno]{Diagram hubungan antara tipe proses dan dyno} 
	\label{fig:process-type-dyno-relationship} 
\end{figure}

\textit{Process type} dan dyno saling berhubungan. \textit{Process type} adalah prototipe yang menjadi tempat dimana dyno dibentuk. Hubungan \textit{process type} dan dyno dapat dilihat di diagram pada Gambar~\ref{fig:process-type-dyno-relationship}. Sumbu x menyatakan \textit{process type} yang dipakai, sementara sumbu y menyatakan jumlah dyno yang berjalan pada \textit{process type} tersebut. Semakin banyak dyno pada suatu \textit{process type} maka konkurensi untuk pekerjaan yang ditangani \textit{process type} tersebut akan meningkat. Semakin banyak \textit{process type} maka semakin beragam beban kerja.

Untuk mengatur berapa banyak dyno yang bekerja di satu \textit{process type}, perintah yang dapat diketikkan pada command shell adalah :
\begin{lstlisting}

	$ heroku ps:scale <process=dyno list>
	
\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{<process=dyno list>} : daftar pasangan \textit{process type} dengan jumlah dyno yang ditugaskan untuk proses tersebut.
\end{itemize}

Contoh : 
\begin{lstlisting}

	$ heroku ps:scale web=2 worker=4 clock=1
	
\end{lstlisting}

Selain dapat mengatur jumlah dyno yang ditugaskan pada suatu pekerjaan, \textit{developer} dapat menjadwalkan proses yang berjalan pada suatu waktu atau jangka waktu tertentu. Caranya dengan menggunakan add-on Heroku Scheduler atau menggunakan \textit{process type} khusus untuk mengatur jadwal pekerjaan.
		
				\item \textbf{Dyno}
		
				Dyno adalah wadah aplikasi berbasis Unix yang terisolasi, tervirtualisasi, dan menyediakan lingkungan yang dibutuhkan untuk menjalankan suatu aplikasi. Umumnya, jika aplikasi di-\textit{deploy} ke Heroku untuk pertama kali, Heroku akan menjalankan satu web dyno secara otomatis.

Setiap dyno termasuk dalam salah satu dari konfigurasi berikut :
\begin{itemize}
\item Web dyno

Web dyno adalah dyno dari \textit{process type} \texttt{web} yang disebutkan di dalam Procfile. Web dyno adalah satu-satunya dyno yang dapat menerima arus HTTP dari router Heroku.

\item Worker dyno

Worker dyno adalah dyno dari \textit{process type} apapun selain \texttt{web} yang disebutkan di dalam Procfile. Worker dyno biasanya digunakan untuk pekerjaan di latar belakang, sistem antrian, dan pekerjaan yang memiliki jangka waktu.

\item One-off dyno

One-off dyno adalah dyno yang bersifat sementara yang dapat berjalan terpisah atau dengan masukan/keluaran dari terminal lokal. Dyno ini dapat digunakan untuk tugas yang bersifat administratif, contoh : migrasi basis data. Dyno ini juga dapat digunakan untuk melakukan pekerjaan di latar belakang yang bersifat sesekali, contoh : Heroku Scheduler.

\end{itemize}

Heroku menyediakan beberapa tipe dyno yang berbeda. Tiap tipe dyno memiliki sifat yang unik dan kinerja yang berbeda. Untuk semua pengguna Heroku, tersedia pilihan dyno tipe Free, Hobby, Standard, dan Performance. Ada satu tipe dyno lagi, yaitu tipe Private. Dyno tipe Private hanya tersedia di Heroku Enterpise yang diperuntukkan untuk organisasi.

Fitur-fitur utama dyno adalah :
\begin{itemize}
\item \textit{Scalability}

Dyno dapat di-\textit{scale} secara horizontal dan vertikal. Untuk melakukan \textit{scale} secara horizontal (\textit{scale out}), tambahkan lebih banyak dyno. Contoh : menambah web dyno agar dapat menangani arus yang lebih besar. Untuk melakukan \textit{scale} secara vertikal (\textit{scale up}), gunakan dyno yang lebih besar. Dyno yang lebih besar berarti jumlah pemakaian memori RAM yang lebih besar. Jumlah RAM maksimal yang tersedia untuk aplikasi tergantung dari tipe dyno yang digunakan. \textit{Scale} secara horizontal dan vertikal ini adalah fitur yang tersedia untuk dyno tipe Standard dan Performance saja.

\item \textit{Redundancy}

Aplikasi dengan banyak dyno yang berjalan akan memiliki resiko kegagalan yang lebih rendah daripada yang sedikit. Jika ada dyno yang hilang, aplikasi dapat terus memproses permintaan sementara dyno yang hilang diganti. Dyno yang hilang biasanya langsung dimulai ulang, tapi terkadang membutuhkan waktu yang lama.

\item \textit{Isolation and security}

Semua dyno terisolasi dari dyno lain untuk alasan keamanan. Walaupun dyno tipe Free, Hobby, dan Standard terisolasi, dyno mungkin berbagi komputasi dasar yang sama. Heroku memiliki teknik tersendiri untuk memastikan penggunaannya adil. Di sisi lain, dyno tipe Performance dan Private tidak berbagi komputasi dasar yang sama dengan dyno lain. Hal ini membuat dyno tipe Performance dan Private memiliki kinerja yang lebih stabil dibanding dengan dyno tipe Free, Hobby, dan Standard. Selain memiliki sumber daya komputasi yang dikhususkan untuknya, dyno tipe Private juga memiliki jaringan virtual yang terisolasi.

\item \textit{Ephemeral filesystem}

Tiap dyno memiliki \textit{ephemeral filesystem}, dengan salinan kode dari hasil deploy terbaru. Saat masa hidup dyno, proses yang dijalankannya dapat menggunakan \textit{filesystem} ini sebagai tempat menulis sementara. Namun, dokumen yang ditulis tidak dapat dilihat oleh proses dari dyno lain dan dokumen yang ditulis akan dihapus saat dyno berhenti bekerja atau dimulai ulang.

\end{itemize}
		
				\item \textbf{Dyno manager}
		
				Dyno manager adalah bagian dari Heroku yang bertanggungjawab untuk menjaga dyno tetap berjalan. Dyno manager melakukan pekerjaan seperti memastikan dyno didaur ulang setidaknya satu kali sehari atau setiap dyno manager mendeteksi kesalahan di dalam aplikasi yang berjalan. Daur ulang dyno ini berlangsung secara transparan dan otomatis secara teratur dan tercatat.

Aplikasi yang menggunakan dyno tipe Free akan masuk mode \texttt{sleep} (tidur) jika tidak ada arus HTTP selama jangka waktu 30 menit. Ketika aplikasi yang tidur menerima arus HTTP, maka aplikasi tersebut akan terbangun. Hal ini menyebabkan aplikasi lebih lambat beberapa detik dari aplikasi yang menggunakan dyno tipe lain. Dyno tipe lain tidak memiliki mode sleep, dan akan selalu terjaga.
		
				\item \textbf{Config vars}
		
				Konfigurasi aplikasi dapat berubah-ubah tergantung lingkungannya. Misalnya, konfigurasi aplikasi saat pengembangan dapat berbeda saat aplikasi siap dirilis ke pengguna. Konfigurasi aplikasi dapat berupa informasi \textit{database}, informasi kredensial, atau informasi lain yang bersifat spesifik pada aplikasi. Konfigurasi ini harus diletakkan pada \textit{environment variable}, bukan di \textit{source code}. Dengan menggunakan \textit{environment variable}, konfigurasi dapat diubah secara terpisah. Selain itu, konfigurasi yang bersifat kredensial dapat terhindar dari tersimpan pada \textit{version control} (pengontrol versi, contoh : Git).

Heroku memungkinkan \textit{developer} untuk menjalankan aplikasi dengan konfigurasi yang dapat diubah dengan mudah. Konfigurasi tersebut diletakkan di luar dari \textit{source code} aplikasi. Konfigurasi dapat diubah secara independen tanpa harus mengubah \textit{source code}. Konfigurasi tersebut disimpan di dalam config vars.

Untuk mengatur config vars ada tiga cara : 
\begin{itemize}
\item Menggunakan Heroku CLI

Config var diatur menggunakan \textit{command shell}. Berikut perintah-perintah untuk mengatur config var menggunakan Heroku CLI:
\begin{enumerate}
\item Menampilkan seluruh config var beserta nilainya : 

\begin{lstlisting}

	$ heroku config

\end{lstlisting}

\item Menampilkan nilai dari config var tertentu 
\begin{lstlisting}

	$ heroku config : get <config var>

\end{lstlisting}
Keterangan :
\texttt{config var} : nama config var


\item Menambah config var

\begin{lstlisting}

	$ heroku config : set <config var> = <config value>

\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{config var} : nama config var
\item \texttt{config value} : nilai dari config var tersebut
\end{itemize}

\item Menghapus config var

\begin{lstlisting}

	$ heroku config : unset <config var>

\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{config var} : nama config var
\end{itemize}

\end{enumerate}

\item Menggunakan Heroku Dashboard

\begin{figure}[H]
	\centering  
	\includegraphics[width=\textwidth]{Gambar/bluetape-config-vars-example.png}  
	\caption[Config vars pada dashboard Heroku]{Config vars pada dashboard Heroku} 
	\label{fig:bluetape-config-vars-example} 
\end{figure}

Config var dapat dilihat, ditambah, dan dihapus melalui menu \texttt{Settings} bagian config vars (Gambar~\ref{fig:bluetape-config-vars-example}).

\item Menggunakan Heroku Platform API

Config var dapat diatur dengan Heroku Platform API menggunakan HTTPS REST client sederhana dan data struktur data JSON. \textit{Developer} perlu Heroku \textit{access token} yang valid yang mewakili pengguna dengan izin yang tepat untuk aplikasi.

\end{itemize}

Config vars akan diperlakukan sebagai \textit{environment variable} oleh program. Contoh : \textit{environment variable} dapat diakses dengan getEnv() pada program dengan bahasa PHP.
 
Dalam mengatur config var, ada beberapa hal yang harus diperhatikan :
\begin{itemize}
\item Setiap config var ditambah atau dihapus, aplikasi akan dimulai ulang dan release baru akan dibuat.
\item Jika aplikasi menggunakan add-on, biasanya add-on tersebut akan menambahkan satu atau lebih config var ke aplikasi. Nilai dari config var tersebut mungkin diperbarui oleh penyedia add-on kapan saja.
\item Config var data (kombinasi dari semua kunci dan nilainya) tidak dapat melebihi 32kb per aplikasi
\item Nama config var tidak boleh diawali dengan garis bawah dua kali (\texttt{\_\_}).
\item Nama config var tidak bisa diawali dengan \texttt{HEROKU\_}, kecuali ditambahkan oleh platform Heroku sendiri.
\end{itemize}
		
				\item \textbf{Add-ons}
		
				Aplikasi biasanya memanfaatkan add-ons untuk menyediakan layanan penyokong seperti basis data, sistem antrean, layanan email, dan lainnya. Add-ons disediakan oleh Heroku atau pihak ketiga. \textit{Developer} dapat mencari add-ons di Elements Marketplace (\url{https://elements.heroku.com/addons}). 

Menambah add-ons selain add-ons Heroku Postgres dan Heroku Connect membutuhkan verifikasi akun. \textit{Developer} dapat menambah add-ons melalui tombol Install di Elements Marketplace atau dengan mengetikkan perintah berikut pada \textit{command shell} :
\begin{lstlisting}

	$ heroku addons:create <nama addons>:<tipe addons>

\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{<nama addons>} : nama addons
\item \texttt{<tipe addons>} : tipe addons
\end{itemize}

Contoh :
\begin{lstlisting}

	$ heroku addons:create heroku-redis:hobby-dev

\end{lstlisting}

				\item \textbf{Slug}
		
				Ketika platform Heroku menerima \textit{source code} aplikasi, heroku akan memulai proses \textit{build} berdasarkan \textit{source code}. Mekanisme \textit{build} biasanya tergantung pada bahasa pemrograman yang dipakai, tapi mengikuti pola yang sama. Mekanisme \textit{build} biasanya mengambil \textit{dependency} yang ditentukan, dan menciptakan aset yang diperlukan. \textit{Source code} untuk aplikasi, \textit{dependency}, dan hasil dari fase \textit{build} digabungkan ke dalam slug. 

Slug adalah gabungan dari \textit{source code}, \textit{dependency} yang diambil, \textit{language runtime}, dan hasil kompilasi atau keluaran yang dihasilkan oleh \textit{build system} yang siap untuk dieksekusi. Slug ini adalah aspek dasar dari eksekusi aplikasi. Slug berisi aplikasi yang sudah dikompilasi, digabungkan, dan siap untuk dijalankan.

Slug dikompilasi oleh slug compiler menggunakan buildpack. Buildpack akan mengambil aplikasi, \textit{dependency}, dan \textit{language runtime} dan kemudian menghasilkan slug. Buildpack bersifat \textit{open source}, sehingga memungkinkan \textit{developer} memperluas Heroku ke bahasa pemrograman lain dan \textit{framework}.

Apabila ada dokumen yang tidak diperlukan untuk menjalankan aplikasi, \textit{developer} dapat menambahkannya ke \texttt{.slugignore}. Dokumen ini harus dibuat di direktori \texttt{root}. Contoh dokumen yang mungkin ingin dimasukkan ke \texttt{.slugignore} :
\begin{itemize}
\item Dokumen pengolah gambar (contoh : dokumen .psd)
\item Dokumen desain (contoh : dokumen .pdf)
\item Data untuk pengujian
\end{itemize}

Contoh isi \texttt{.slugignore} :
\begin{lstlisting}
# Heres a comment
*.psd
*.pdf
/test
/spec
\end{lstlisting}

Ukuran slug dapat terlihat di akhir kompilasi (apabila kompilasi berhasil). Maksimum ukuran slug adalah 500 MB. Ukuran slug bervariasi berdasarkan bahasa atau \textit{framework} yang digunakan, banyak \textit{dependency} yang ditambahkan, dan faktor lain dari aplikasi. Slug yang ukurannya lebih kecil dapat ditransfer ke dyno manager dengan lebih cepat.

				\item \textbf{Buildpack}
		
				Buildpack bertanggung jawab untuk mengubah \textit{source code} menjadi slug, sehingga dyno dapat mengeksekusinya. Buildpack terdiri dari sekumpulan \textit{script} yang ditulis dalam bahasa pemrograman yang sama dengan \textit{source code}. Script tersebut akan mengambil \textit{dependency}, mengeluarkan aset atau kode yang sudah dikompilasi, dan sebagainya. Keluaran ini akan digabungkan ke dalam slug oleh slug compiler.

Heroku memiliki sekumpulan \textit{officially supported buildpack} yang tersedia secara default untuk semua aplikasi Heroku selama kompilasi slug. Daftar \textit{officially supported buildpack} terdapat pada Gambar~\ref{fig:heroku-buildpack-table}. Kolom \texttt{Buildpack} menyatakan nama buildpack dan kolom \texttt{shorthand} menyatakan nama panggil buildpack saat di CLI.

\begin{figure}[H]
	\centering  
	\includegraphics[scale=0.5]{Gambar/heroku-buildpack-table.png}  
	\caption[Tabel buildpack heroku]{Tabel buildpack heroku} 
	\label{fig:heroku-buildpack-table} 
\end{figure}

Heroku akan mencari buildpack yang sesuai dan menggunakannya untuk mengompilasi aplikasi. Jika build sukses, buildpack yang sudah terdeteksi sesuai akan secara permanen diatur untuk push selanjutnya. Buildpack yang telah dimodifikasi dapat dipakai untuk mendukung bahasa atau framework yang tidak dapat di cakup oleh buildpack resmi.

Biasanya buildpack yang dipakai oleh aplikasi hanya satu, tapi ada beberapa kasus buildpack yang dipakai tidak cukup hanya satu. Beberapa kasus tersebut adalah :
\begin{itemize}
\item Menjalankan buildpack untuk tiap bahasa pemrograman yang aplikasi gunakan. Contohnya, menjalankan JavaScript buildpack untuk aset dan buildpack Ruby untuk aplikasi.
\item Menjalankan proses daemon seperti \texttt{pgbouncer} dengan aplikasi.
\item Menarik \textit{dependency} sistem dengan apt.
\end{itemize}

Berikut adalah perintah-perintah dasar buildpack yang dapat diketikkan pada \textit{command shell} :
\begin{itemize}
\item Mengatur buildpack yang dipakai saat aplikasi pertama kali dibuat
\begin{lstlisting}

	$ heroku create myapp --buildpack <nama buildpack>
	
\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{<nama buildpack>} : nama panggil buildpack yang ingin dipakai, contoh : \texttt{heroku/php}.
\end{itemize}

Buildpack juga dapat secara eksplisit diatur di dalam app.json sehingga aplikasi yang dibuat menggunakan tombol Heroku dapat menggunakan buildpack yang telah dimodifikasi.

\item Mengubah dengan mengatur nilai buildpack

\begin{lstlisting}

	$ heroku buildpacks:set <nama buildpack>
	
\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{<nama buildpack>} : nama panggil buildpack yang ingin dipakai, contoh : \texttt{heroku/php}.
\end{itemize}

\item Menghilangkan buildpack dari aplikasi

\begin{lstlisting}

	$ heroku buildpacks:remove <nama buildpack>
	
\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{<nama buildpack>} : nama panggil buildpack yang ingin dipakai, contoh : \texttt{heroku/php}.
\end{itemize}

\item Mencari buildpack

\begin{lstlisting}

	$ heroku buildpacks:search <kata kunci>
	
\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{<kata kunci>} : kata kunci pencarian, misalnya : bahasa pemrograman yang dipakai. Contoh : \texttt{elixir}.
\end{itemize}

\item Menampilkan informasi buildpack

\begin{lstlisting}

	$ heroku buildpacks:info <nama buildpack>
	
\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{<nama buildpack>} : nama panggil buildpack yang ingin dipakai, contoh : \texttt{heroku/php}.
\end{itemize}

\item Mengembalikan aplikasi ke buildpack awalnya

\begin{lstlisting}

	$ heroku buildpacks:clear
	
\end{lstlisting}

\item Mengatur urutan eksekusi buildpack

\begin{lstlisting}

	$ heroku buildpacks:set --index <index> <nama buildpack>

\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{<index>} : urutan eksekusi buildpack
\item \texttt{<nama buildpack>} : nama panggil buildpack yang ingin dipakai, contoh : \texttt{heroku/php}.
\end{itemize}

\item Melihat daftar buildpack

\begin{lstlisting}

	$ heroku buildpacks

\end{lstlisting}

\end{itemize}
		
				\item \textbf{Stack}
		
				Stack adalah sistem operasi yang dikelola dan dipelihara oleh Heroku. Stack biasanya berlandaskan distribusi dari Linux yang ada, seperti Ubuntu. \textit{Developer} dapat menentukan stack yang dipakai, dan buildpack akan mengubah \textit{source code} menjadi paket yang dapat dieksekusi dengan stack tersebut. Saat skripsi ini dibuat, Heroku menyediakan tiga stack : Cedar-14, Heroku-16, dan Heroku-18. Cedar-14 berbasis Ubuntu 14.04 dan didukung sampai bulan April tahun 2019. Heroku-16 berbasis Ubuntu 16.04 dan didukung sampai bulan April tahun 2021. Heroku-18 berbasis Ubuntu 18.04 dan didukung sampai bulan April tahun 2023. Semua buildpack dari Heroku dapat bekerja dengan ketiga stack tersebut, namun buildpack yang merupakan hasil modifikasi belum tentu dapat bekerja dengan semua stack.

Untuk melihat stack yang dipakai oleh aplikasi, \textit{developer} dapat mengetikkan perintah berikut pada \textit{command shell}:
\begin{lstlisting}

	$ heroku stack

\end{lstlisting}

Untuk mengganti stack yang dipakai, \textit{developer} dapat mengetikkan perintah berikut pada \textit{command shell}:
\begin{lstlisting}

	$ heroku stack:set <stack>

\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{<stack>} dapat diisi dengan \texttt{cedar-14}, \texttt{heroku-16}, atau \texttt{heroku-18}.
\end{itemize}
		
				\item \textbf{Region}
		
				Aplikasi di dalam Heroku dapat disebarkan ke lokasi geografis yang berbeda. Lokasi yang tersedia untuk suatu aplikasi tergantung pada Runtime yang dipakai oleh aplikasi (Common Runtime atau Private Space). Untuk aplikasi yang memakai Common Runtime, \textit{developer} perlu menyebutkan region aplikasi saat membuat aplikasi. Untuk aplikasi yang memakai Private Space, region diatur saat membuat Private Space. Apabila \textit{developer} tidak menyebutkan region yang dipakai, maka region akan diisi secara otomatis sebagai \texttt{us} (apabila memakai Common Runtime) atau \texttt{virginia} (apabila memakai Private Spaces).

Region berpengaruh terhadap add-ons. Apabila add-ons tidak tersedia di region yang sama dengan aplikasi, maka add-ons akan gagal terpasang. Region juga dapat mempengaruhi cara kerja SSL.

Berikut perintah-perintah dasar region yang dapat diketikkan pada \textit{command shell} :
\begin{itemize}
\item Memeriksa region yang tersedia di Heroku

\begin{lstlisting}

	$ heroku regions

\end{lstlisting}

\item Mengatur region aplikasi

\begin{lstlisting}

	$ heroku create --region <id region>

\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{<id region>} : id region yang ingin dipakai, contoh : \texttt{eu}.Id region bisa dilihat dengan memeriksa daftar region yang tersedia.
\end{itemize}

\item Memeriksa region yang dipakai oleh aplikasi

\begin{lstlisting}

	$ heroku info

\end{lstlisting}

\end{itemize}
		
				\item \textbf{Releases}
		
				Setiap ada deploy baru, perubahan di config vars, dan perubahan di daftar add-ons, Heroku akan membuat release baru dan memulai ulang aplikasi. Releases adalah buku besar yang mencatat setiap release tersebut. \textit{Developer} dapat melihat catatan releases ini dengan menggunakan perintah :
\begin{lstlisting}

	$ heroku releases

\end{lstlisting}

Isi dari releases adalah satu atau lebih baris dari release yang tiap barisnya memiliki format : 
\begin{lstlisting}

	<versi deploy> Deploy <commit hash> <username \textit{developer}> <waktu deploy> 

\end{lstlisting}

Contoh isi releases :
\begin{lstlisting}

	== demoapp Releases
	v103 Deploy 582fc95  jon@heroku.com   2013/01/31 12:15:35
	v102 Deploy 990d916  jon@heroku.com   2013/01/31 12:01:12
	
\end{lstlisting}

Releases ini berguna saat \textit{developer} ingin mengembalikan aplikasi ke deploy lama. Cara mengembalikan aplikasi ke deploy lama dengan mengetikkan perintah berikut pada \textit{command shell}:
\begin{lstlisting}

	$ heroku releases:rollback <version>

\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{<version>} : versi deploy
\end{itemize}

Contoh :
\begin{lstlisting}

	$ heroku releases:rollback v102

\end{lstlisting}
		
				\item \textbf{Log}
		
				Log adalah catatan setiap proses yang terjadi di aplikasi. Heroku menggunakan Logplex untuk menyampaikan log ini. Logplex akan secara otomatis menambahkan entri log baru dari semua dyno yang berjalan di aplikasi, dan juga komponen lain seperti router. \textit{Developer} dapat memeriksa log dengan cara mengetikkan perintah berikut pada \textit{command shell}:
\begin{lstlisting}

	$ heroku logs

\end{lstlisting}

Contoh isi log adalah :
\begin{lstlisting}

	2013-02-11T15:19:10+00:00 heroku[router]: at=info method=GET path=/articles/custom-domains host=mydemoapp.heroku.com fwd=74.58.173.188 dyno=web.1 queue=0 wait=0ms connect=0ms service=1452ms status=200 bytes=5783
	2013-02-11T15:19:10+00:00 app[web.2]: Started GET "/" for 1.169.38.175 at 2013-02-11 15:19:10 +0000
	2013-02-11T15:19:10+00:00 app[web.1]: Started GET "/" for 2.161.132.15 at 2013-02-11 15:20:10 +0000

\end{lstlisting}
		
			\end{itemize}
		
			\textbf{Deploy perangkat lunak}
		
			Heroku menggunakan Git sebagai sarana  utama untuk melakukan deploy aplikasi. Deploy adalah proses penyebaran aplikasi dari satu lingkungan ke lingkungan lain, misalnya dari lingkungan mesin \textit{developer} aplikasi ke lingkungan heroku. Namun, Heroku juga menyediakan cara lain untuk melakukan deploy :
\begin{itemize}
\item Docker
\item GitHub
\item Tombol \texttt{Deploy} di dashboard Heroku
\item WAR deployment
\end{itemize}

\begin{enumerate}
\item \textbf{Deploy Menggunakan Git}

Untuk melakukan deploy menggunakan Git, \textit{developer} harus sudah memasang Git. \textit{Developer} dapat mengikuti petunjuk unduhan pada \url{https://git-scm.com}. Sebelum \textit{developer} dapat melakukan deploy dengan Git, \textit{developer} perlu menginisialisasi git. Berikut perintah-perintah yang harus dijalankan pada \textit{command shell} :
\begin{lstlisting}

	$ git init
	$ git add .
	$ git commit -m "<message>"

\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{<message>} : pesan yang mewakili commit.
\end{itemize}

Setelahnya, \textit{developer} dapat membuat aplikasi Heroku. Setiap aplikasi Heroku dibuat, maka \texttt{git remote} secara otomatis juga dibuat. \textit{Developer} dapat memeriksanya dengan mengetikkan perintah berikut pada \textit{command shell} :
\begin{lstlisting}

	$ git remote // Untuk daftar nama remote saja
	$ git remote -v // Untuk informasi yang lebih detail

\end{lstlisting}

Untuk mengubah nama remote, \textit{developer} dapat mengetikkan perintah berikut pada \textit{command shell} :
\begin{lstlisting}

	$ git remote rename <nama lama> <nama baru>

\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{<nama lama>} : nama remote yang ingin diganti.
\item \texttt{<nama baru>} : nama baru untuk remote tersebut.
\end{itemize}

Untuk melakukan deploy, \textit{developer} dapat mengetikkan perintah berikut pada \textit{command shell} :
\begin{lstlisting}

	$ git push <nama remote> <nama branch>

\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{<nama remote>} : nama remote dari tujuan deploy. Bila \textit{developer} tidak mengubah nama remote, nama remotenya adalah \texttt{heroku}. 
\item \texttt{<nama branch>} : nama cabang dari tujuan deploy. Heroku secara otomatis membuat satu cabang bernama \texttt{master}.
\end{itemize}

\item \textbf{Deploy Menggunakan Docker}

Untuk melakukan deploy menggunakan Docker, \textit{developer} harus sudah memasang Docker dan telah masuk ke akun Heroku (\texttt{heroku login}). Setelah itu, \textit{developer} harus mengikuti langkah-langkah ini :
\begin{itemize}
\item Masuk ke Container Registry
\begin{lstlisting}

	$ heroku container:login

\end{lstlisting}

\item Clone source code contoh dari Alpine
\begin{lstlisting}

	$ git clone https://github.com/heroku/alpinehelloworld.git

\end{lstlisting}

\item Membuat aplikasi Heroku baru
\begin{lstlisting}

	$ heroku create

\end{lstlisting}

\item Membangun image dan melakukan deploy ke Container Registry
\begin{lstlisting}

	$ heroku container:push web

\end{lstlisting}

\item Melepaskan image ke aplikasi
\begin{lstlisting}

	$ heroku container:release web

\end{lstlisting}
\item Membuka aplikasi
\begin{lstlisting}

	$ heroku open

\end{lstlisting}
\end{itemize}

\item \textbf{Deploy Menggunakan GitHub}

\begin{figure}[H]
	\centering  
	\includegraphics[scale=0.5]{Gambar/deploy-github-dashboard.jpg}  
	\caption[Deploy menggunakan Github Dashboard]{Deploy menggunakan Github Dashboard} 
	\label{fig:deploy-github-dashboard} 
\end{figure}
Deploy dengan cara ini membuat Heroku dapat dengan otomatis melakukan deploy ke GitHub apabila build berhasil. \textit{Developer} perlu mengaktifkan GitHub integration terlebih dahulu sebelum dapat melakukan deploy. Setelah itu, \textit{developer} harus melakukan autentikasi dengan akun GitHub. Autentikasi ini hanya perlu dilakukan satu kali per satu akun Heroku. Setelah itu, \textit{developer} dapat memilih repository yang ingin disambungkan dengan aplikasi Heroku (Gambar~\ref{fig:deploy-github-dashboard}).

\begin{figure}[H]
	\centering  
	\includegraphics[scale=0.5]{Gambar/deploy-github-manual.jpg}  
	\caption[Deploy menggunakan Github secara manual]{Deploy menggunakan Github secara manual} 
	\label{fig:deploy-github-manual} 
\end{figure}
\begin{figure}[H]
	\centering  
	\includegraphics[scale=0.5]{Gambar/deploy-github-automatic.jpg}  
	\caption[Deploy menggunakan Github secara otomatis]{Deploy menggunakan Github secara otomatis} 
	\label{fig:deploy-github-automatic} 
\end{figure}
Ada dua cara untuk melakukan deploy, yaitu secara manual dan secara otomatis. Untuk cara manual, \textit{developer} melakukan deploy dari GitHub (Gambar~\ref{fig:deploy-github-manual}). Untuk cara otomatis, \textit{developer} harus mengaktifkan "Automatic deploys from GitHub" (Gambar~\ref{fig:deploy-github-automatic}).

\item \textbf{Deploy Langsung di situs Heroku}

Tombol "Deploy to Heroku" memungkinkan pengguna untuk melakukan deploy aplikasi tanpa meninggalkan situs Heroku dan hampir tidak memerlukan konfigurasi. Penggunaan tombol ini ideal untuk pelanggan, dan pemelihara proyek yang bersifat open-source. Sebelum dapat melakukan deploy dengan cara ini, aplikasi harus memiliki dokumen \texttt{app.json} yang sah di direktori root, dan source code aplikasi harus berada di repository GitHub.

\texttt{app.json} adalah dokumen berisi deskripsi aplikasi web. Isinya dapat berupa environment variable, add-ons, dan informasi lain yang diperlukan untuk menjalankan aplikasi pada Heroku. Heroku tidak mewajibkan \textit{developer} menuliskan informasi tertentu, tapi Heroku merekomendasikan untuk setidaknya menuliskan nama aplikasi(\texttt{name}), deskripsi aplikasi (\texttt{description}), dan logo aplikasi (\texttt{logo}). Berikut contoh isi dari \texttt{app.json} :
\begin{lstlisting}

{
  "name": "Node.js Sample",
  "description": "A barebones Node.js app using Express 4",
  "repository": "https://github.com/heroku/node-js-sample",
  "logo": "https://node-js-sample.herokuapp.com/node.png",
  "keywords": ["node", "express", "static"]
}

\end{lstlisting}

\item \textbf{WAR Deployment}

WAR (Web Application ARchive) adalah jenis dokumen arsip yang digunakan untuk membungkus aplikasi web. Dokumen ini dapat berisi halaman web statis, dokumen XML, dan lain-lain.
 
Heroku mendukung deploy dokumen WAR melalui Git deployment dan melalui Heroku Maven plugin. Setelan standar server untuk keduanya adalah Tomcat 8.

\end{enumerate}

			\textbf{Basis data dan manajemen data}
		
			Heroku menyediakan tiga layanan data untuk semua pelanggan :
\begin{itemize}
\item \textbf{Heroku Postgres}

Heroku Postgres adalah basis data SQL yang disediakan secara langsung oleh Heroku. Heroku Postgres dapat diakses oleh bahasa apapun dengan PostgreSQL driver. Heroku secara otomatis menambahkan add-ons Heroku Postgres setiap aplikasi dibuat, sehingga \textit{developer} tidak perlu menambahkannya secara manual. Namun, \textit{developer} dapat menambahkannya secara manual, dengan mengetikkan perintah berikut pada \textit{command shell} :
\begin{lstlisting}
	
	$ heroku addons:create heroku-postgresql:<PLAN_NAME>
	
\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{<PLAN\_NAME>} : nama plan Heroku Postgres yang ingin dipakai. Heroku secara otomatis menggunakan Heroku Postgres tipe \texttt{hobby-dev}.
\end{itemize}

Heroku Postgres memiliki lima plan :
\begin{itemize}
\item Hobby Tier : untuk aplikasi dengan toleransi gagal bekerja sampai 4 jam per bulan.
\item Standard Tier : untuk aplikasi dengan toleransi gagal bekerja sampai 1 jam per bulan.
\item Premium Tier : untuk aplikasi dengan toleransi gagal bekerja sampai 15 menit per bulan.
\item Private Tier : untuk pengguna Heroku Enterprise, memiliki toleransi gagal bekerja sampai 15 menit per bulan.
\item Shield Tier : untuk pengguna Heroku Enterprise yang menginginkan basis data yang compliance-capable, memiliki toleransi gagal bekerja sampai 15 menit per bulan.
\end{itemize}

Gambar~\ref{fig:heroku-postgres-plan-table} menunjukkan tabel perbedaan antara plan. Hanya plan Hobby yang gratis. Plan lain memiliki harga yang bervariasi berdasarkan ukuran RAM, batas penyimpanan, dan batas koneksi yang bisa dibuat.
\begin{figure}[H]
	\centering  
	\includegraphics[scale=0.5]{Gambar/heroku-postgres-plan-table.png}  
	\caption[Tabel plan Heroku Postgres]{Tabel plan Heroku Postgres} 
	\label{fig:heroku-postgres-plan-table} 
\end{figure}

Semua plan memiliki fitur yang sama :
\begin{itemize}
\item Dapat mengelola layanan basis data secara menyeluruh dengan fitur \textit{automatic health checks}
\item Write-ahead log (WAL) menjauh dari tempat penyimpanan setiap 60 detik, memastikan resiko kehilangan data dan kesalahan lainnya seminimal mungkin
\item Backup basis data harian menggunakan PG Backups (opsional, tapi gratis)
\item Dataclips untuk berbagi data dan query yang mudah dan aman
\item Akses psql/libpq dengan SSL-protected
\item Menjalankan Postgres 9.4, 9.5, 9.6, atau 10 tanpa modifikasi
\item Ekstensi Postgres
\item Fitur web UI (\url{https://data.heroku.com/})
\end{itemize}

\textit{Developer} juga dapat menambahkan versi yang ingin dipakai dengan cara menambahkan \texttt{--version} di belakang perintah tersebut, contoh :
\begin{lstlisting}
	
	$ heroku addons:create heroku-postgresql:<PLAN_NAME--version=9.5
	
\end{lstlisting}
Secara otomatis, Heroku menggunakan versi paling baru dari Heroku Postgres. Saat skripsi ini ditulis, versi terbaru adalah versi 10.

Setelah dipasang, Heroku akan secara otomatis menambahkan config var \texttt{DATABASE\_URL} ke aplikasi. Apabila Heroku Postgres yang dipakai ada lebih dari satu, nama config var akan menjadi \texttt{HEROKU\_POSTGRESQL\_<COLOR>\_URL} dengan <COLOR> adalah nama warna yang dihasilkan secara acak. Contoh : \texttt{HEROKU\_POSTGRESQL\_<BLUE>\_URL}.

Apabila \textit{developer} menggunakan lebih dari satu basis data, \textit{developer} dapat mengatur basis data utama. Basis data utama dapat diatur dengan mengetikkan perintah berikut pada \textit{command shell} :
\begin{lstlisting}
	
	$ heroku pg:promote <database_url>
	
\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{<database\_url>} : url dari basis data.
\end{itemize}

Apabila \textit{developer} ingin berbagi Heroku Postgres kepada banyak aplikasi, \textit{developer} dapat mengetikkan perintah berikut pada \textit{command shell} : 
\begin{lstlisting}

	$ heroku addons:attach <originating_app>::DATABASE --app <receiver-app>
	
\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{<originating\_app>} : nama aplikasi yang memiliki basis data yang ingin dibagi ke aplikasi lain. 
\item \texttt{<receiver-app>} : nama aplikasi yang akan menerima basis data dari aplikasi lain.
\end{itemize}

\textit{Developer} dapat berhenti berbagi basis data dengan mengetikkan perintah berikut pada \textit{command shell} :
\begin{lstlisting}

	$ heroku addons:detach <database_url> --app <application_name>

\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{<database\_url>} : url dari basis data
\item \texttt{<application\_name>} : nama aplikasinya.
\end{itemize}

Berikut adalah perintah-perintah dasar dari Heroku Postgres yang dapat diketikkan pada \textit{command shell}:
\begin{itemize}
\item Melihat semua basis data milik aplikasi dan karakteristiknya

\begin{lstlisting}

	$ heroku pg:info

\end{lstlisting}

\item Mengawasi status basis data secara terus menerus

\begin{lstlisting}

	$ watch heroku pg:info

\end{lstlisting}

\item Mengadakan sesi \texttt{psql} dengan basis data

\begin{lstlisting}

	$ heroku pg:psql

\end{lstlisting}
atau
\begin{lstlisting}

	$ heroku pg:psql <database_name>

\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{<database\_name>} diisi dengan nama basis data atau cukup warna basis data (misal : \texttt{gray}).
\end{itemize}

\item Menarik data dari basis data Heroku Postgres ke basis data di mesin lokal

\begin{lstlisting}

	$ heroku pg:pull

\end{lstlisting}

\item Memasukkan data dari basis data di mesin lokal ke basis data di Heroku Postgres

\begin{lstlisting}

	$ heroku pg:push <nama_db_lokal> <nama_db_heroku> --app <nama_aplikasi>

\end{lstlisting}

\item Melihat daftar query yang berjalan

\begin{lstlisting}

	$ heroku pg:ps
	// Contoh hasil :
	procpid |         source            |   running_for   | waiting |         query
	--------+--------+-------------+---------+-----------------------
	   31776 | psql                      | 00:19:08.017088 | f       | <IDLE> in transaction
	   31912 | psql                      | 00:18:56.12178  | t       | select * from hello;
	   32670 | Heroku Postgres Data Clip | 00:00:25.625609 | f       | BEGIN READ ONLY; select 'hi'
	(3 rows)
	
\end{lstlisting}

\item Menghentikan query yang berjalan

\begin{lstlisting}

	$ heroku pg:kill <procpid>

\end{lstlisting}

\item Menghentikan query yang berjalan secara paksa

\begin{lstlisting}

	$ heroku pg:kill --force <procpid>

\end{lstlisting}

\item Menghentikan semua query yang berjalan

\begin{lstlisting}

	$ heroku pg:killall

\end{lstlisting}

\item Menghapus semua data di dalam basis data

\begin{lstlisting}

	$ heroku pg:reset <nama database>

\end{lstlisting}
\end{itemize}

Basis data Heroku Postgres dapat diakses secara langsung oleh komputer. Informasi yang dibutuhkan untuk mengakses data dari komputer dapat dilihat dengan mengetikkan perintah :
\begin{lstlisting}

	$ heroku pg:credentials DATABASE
	
\end{lstlisting}
atau
\begin{lstlisting}

	$ heroku config | grep HEROKU_POSTGRESQL
	
\end{lstlisting}
Pada saat akan melakukan koneksi langsung di komputer, \textit{developer} harus memastikan pengaturan \texttt{sslmode=require} pada pengaturan SSL.

\item \textbf{Heroku Redis}

Heroku Redis adalah basis data berbasis \textit{key-value store} yang bersifat \textit{in-memory}. Heroku dijalankan oleh Heroku dan dikelola sebagai add-on Heroku Redis dapat diakses oleh bahasa apapun dengan Redis driver. Cara memasang add-on Heroku Redis pada \textit{command shell}:
\begin{lstlisting}
	
	$ heroku addons:create heroku-redis: <PLAN_NAME>
	
\end{lstlisting}
Keterangan :
\begin{itemize}
\item \texttt{<PLAN\_NAME>} : tipe Heroku Redis yang ingin dipakai. Heroku Redis memiliki dua tipe : Hobby Dev dan Premium. Hobby Dev gratis, sedangkan Premium berbayar. Perbedaannya terletak pada jumlah memori dan batas koneksi yang dapat dibuat.
\end{itemize}

Heroku Redis memiliki kelebihan sebagai berikut :
\begin{itemize}
\item Memiliki analisa performa yang dapat membantu menemukan masalah basis data dengan mudah
\item Heroku dapat diskala sesuai kebutuhan memori dan koneksi.
\end{itemize}

\item \textbf{Apache Kafka}

Apache Kafka adalah salah satu add-on di Heroku yang disediakan oleh Kafka yang berintegrasi penuh dengan Heroku. Apache Kafka dideskripsikan Kafka dideskripsikan oleh Heroku sebagai add-on yang memungkinkan \textit{developer} mendistribusikan aplikasi yang dapat menangani jutaan event dan miliaran transaksi. Kafka didesain untuk memindahkan \textit{ephemeral data} yang sangat besar dengan reliabilitas yang tinggi dan toleran akan kerusakan.

\textit{Developer} harus memasang Python 2.7, node 8.x, .NET Framework, dan Visual C++ Build Tools terlebih dahulu sebelum memasang Apache Kafka. Setelah itu, \textit{developer} mengetikkan perintah :
\begin{lstlisting}
	
	$ heroku plugins:install heroku-kafka
	
\end{lstlisting}
\end{itemize}
Heroku juga menyediakan pilihan lain untuk pelanggan Heroku Enterprise, yaitu Heroku Connect. Selain itu, Heroku juga memungkinkan penggunaan layanan data dari pihak ketiga. Layanan data dari pihak ketiga ini tersedia sebagai add-ons.

			\textbf{Verifikasi akun}
			
			Heroku membutuhkan identitas terpercaya dan kontak dari pengguna. Heroku menganggap mempunyai informasi kartu kredit adalah cara yang paling dapat diandalkan untuk mendapatkan informasi kontak yang terverifikasi. Verifikasi akun juga membantu Heroku untuk menghindari penyalahgunaan.

Verifikasi akun dibutuhkan untuk :
\begin{itemize}
\item Menggunakan lebih dari satu dyno di dalam aplikasi.
\item Menambah add-on, termasuk yang gratis. Pengecualian untuk Heroku Postgres dan Heroku Connect.
\item Mengubah domain aplikasi.
\item Menerima transfer dari aplikasi yang memiliki sumber daya berbayar.
\item Menambah batas standar penggunaan one-off dyno.
\item Memiliki lebih dari 5 aplikasi dalam satu waktu.  Akun yang terverifikasi dapat memiliki sampai 100 aplikasi.
\end{itemize}

Cara melakukan verifikasi akun Heroku :
\begin{itemize}
\item Pergi ke Account Settings (\url{https://dashboard.heroku.com/account})
\item Menekan tab Billing
\item Menekan tombol Add Credit Card
\end{itemize}

Kartu kredit yang diterima oleh Heroku adalah kartu Visa, MasterCard, American Express, Discover dan JCB. Kartu debit juga diterima untuk kartu Visa, MasterCard atau JCB. Kartu lain tidak diterima. Beberapa bank mungkin mensyaratkan penahanan satu dollar oleh pelaku verifikasi sebelum kartu dapat dikonfirmasi.
		
		\item \textbf{Gmail}		
		
		Gmail adalah layanan email yang disediakan oleh Google LLC. Gmail API dapat digunakan untuk mengakses email Gmail.

		\begin{itemize}
			\item \textbf{Resource}
			
			Gmail API menyediakan beberapa jenis \textit{resource} :
\begin{itemize}
\item Message

Message merepresentasikan pesan dalam email. Message hanya bisa dibuat atau dihapus. Tidak ada properti dari message yang bisa diubah selain label yang diberikan ke message.

\item Label

Label berfungsi sebagai sarana utama untuk mengelompokkan dan mengatur message dan thread. Label mempunyai hubungan banyak ke banyak dengan message. Artinya, satu message dapat memiliki beberapa label dan satu label dapat diberikan ke beberapa message.

Label ada dua jenis : label sistem dan label pengguna. Contoh label sistem adalah label \texttt{INBOX}, \texttt{TRASH}, dan \texttt{SPAM}. Label sistem dibuat secara internal dan tidak dapat dibuat, dihapus, dan dimodifikasi. Namun, beberapa label sistem dapat diberikan ke message atau dilepaskan dari message. Label pengguna dapat ditambah, dihapus, dan dimodifikasi oleh pengguna atau aplikasi.

\item Draft

Draft merepresentasikan message yang belum dikirim. Message tidak bisa dimodifikasi setelah dibuat, tapi message yang terdapat di dalam draf dapat dimodifikasi. Mengirimkan draft secara otomatis akan menghapus draft tersebut dan membuatnya menjadi message dengan label sistem SENT.

\item History

History adalah riwayat modifikasi message yang diurutkan secara kronologis. History hanya menyimpan perubahan dalam jangka waktu 30 hari.

\item Thread

Thread adalah kumpulan message yang merepresentasikan percakapan. Thread dapat memiliki label. Thread tidak dapat dibuat, tapi dapat dihapus. Message dapat dimasukkan ke Thread.

\item Setting

Setting mengontrol perilaku fitur pada Gmail kepda User. Setting tersedia untuk akses POP dan IMAP, forward email, filter, vacation auto-response, send-as aliases, signatures, dan delegates.

\end{itemize}
			
			\item \textbf{Scope}
			
			Gmail API menggunakan OAuth 2.0 untuk menangani autentikasi dan authorization. \textit{Developer} harus menyebutkan scope yang dipakai di aplikasi. Scope adalah string yang mengidentifikasi resource yang ingin di akses. Scope ini digunakan bersama dengan token untuk mengamankan akses ke resource pengguna. Token tersebut memiliki masa kadaluarsa. Contoh scope :
\begin{itemize}
\item \url{https://www.googleapis.com/auth/gmail.readonly} : scope untuk membaca message dari Gmail
\item \url{https://www.googleapis.com/auth/gmail.modify} : scope untuk mengubah label pada thread atau message
\item \url{https://www.googleapis.com/auth/gmail.compose} : scope untuk mengirim message mewakili pengguna
\end{itemize}
			
			\item \textbf{Penggunaan pada umumnya}
			
			\begin{itemize}
				\item Mengirim message

\begin{enumerate}
\item Membuat konten email
\item Membuat string yang dikodekan berdasarkan base64url dari konten
\item Membuat resource message dan memasukkan string tersebut ke properti \texttt{raw}
\item Memanggil \texttt{message.send} untuk mengirim message
\end{enumerate}

				\item Mengambil email yang diterima
			
				Mengambil email yang diterima membutuhkan ID email. Mengambil email yang diterima dapat dilakukan dengan metode \texttt{get} dari resource User.messages. Saat mengambil message, format dari respon dapat diatur. Format \texttt{FULL} mengembalikan seluruh informasi dari message. Format \texttt{MINIMAL} hanya mengembalikan metadata seperti label. Format \texttt{RAW} mengembalikan properti \texttt{raw} saja. Secara otomatis, format dari respon memakai format \texttt{FULL}.
			
				\item Perubahan di history
			
				Perubahan message direpresentasikan oleh \texttt{History objects}. Properti \texttt{start\_history\_id} memperbolehkan \textit{developer} mengatur dari titik mana perubahan ingin dikembalikan. Beberapa perubahan dapat mempengaruhi lebih dari satu message, sehingga history yang merepresentasikan perubahan tersebut akan berisi beberapa message.
			
				\item Manajemen Label
			
				Label yang diberikan ke sebuah thread juga diberikan ke semua message di dalam thread. Jika sebuah label dihapus, label tersebut akan dihapus dari semua thread dan message yang memiliki label tersebut. Properti \texttt{messageListVisibility} digunakan untuk menentukan apakah message dengan label tersebut ada di message list. Properti \texttt{labelListVisibility} digunakan untuk menentukan apakah ada label tersebut di daftar label. Untuk mengubah label, gunakan \texttt{messages.modify} dan\texttt{threads.modify}.
			
			\end{itemize}
			
		\end{itemize}
		
		\item \textbf{PHP IMAP}
		
		PHP IMAP adalah layanan PHP untuk mengakses email melalui protokol IMAP.  Berikut adalah \textit{function} dasar dari imap :
		\begin{itemize}
			\item imap\_8bit : melakukan konversi 8bit string ke quoted-printable string
			\item imap\_alerts : mengembalikan semua pesan peringatan dari IMAP yang telah terjadi
			\item imap\_base64 : decode BASE64 encoded text
			\item imap\_binary : melakukan konversi 8bit string ke base64 string
			\item imap\_body : membaca message body
			\item imap\_bodystruct : membaca struktur dari bagian body tertentu dari message tertentu
			\item imap\_check : mengecek mailbox (kotak surat)
			\item imap\_close : menutup IMAP stream
			\item imap\_errors : mengembalikan semua error dari IMAP yang telah terjadi
			\item imap\_fetch\_overview : membaca informasi pada header dari message yang diberikan
			\item imap\_fetchbody : mengambil bagian tertentu dari message body
			\item imap\_fetchheader : mengembalikan header dari message
			\item imap\_fetchmime : mengambil MIME headers dari bagian tertentu dari message
			\item imap\_fetchstructure : membaca struktur dari message tertentu
			\item imap\_headerinfo : membaca header dari message
			\item imap\_open : membuka IMAP stream ke mailbox
			\item imap\_qprint : melakukan konversi dari quoted-printable string ke 8 bit string
			\item imap\_sort : mendapatkan dan menyortir message
			\item imap\_utf8 : melakukan konversi dari MIME-encoded text ke UTF-8
		\end{itemize}
		
		\item \textbf{LINE}
		
		Line Menyediakan Messaging API untuk membangun messaging bot. Messaging API memungkinkan data dioper antara server dari aplikasi bot dengan LINE Platform. Ketika pengguna Line mengirimkan pesan ke bot, sebuah webhook akan terpicu dan LINE Platform akan mengirimkan permintaan ke URL webhook bot. Server akan mengirim permintaan ke LINE Platform untuk merespon pengguna. Permintaan akan dikirimkan dalam format JSON.
		
		Untuk menggunakan Messaging API, \textit{developer} memerlukan akun LINE@. Messaging API juga dapat digunakan menggunakan akun resmi/\textit{official accounts}. Akun resmi mendapatkan fitur tambahan untuk pengguna enterprise.
\\
\\
\textbf{Membuat Channel}\\
Untuk memulai membangun bot dengan Messaging API, \textit{developer} perlu membuat channel terlebih dahulu. Channel adalah penyambung antara LINE platform dan aplikasi yang dibuat \textit{developer}. Berikut langkah-langkah untuk membuat channel :
\begin{enumerate}
\item Langkah ke-1 : Masuk ke LINE Developers console

\begin{figure}[H]
	\centering  
	\includegraphics[scale=0.4]{Gambar/line-developers-console-login.png}  
	\caption[Tampilan LINE developer console saat login]{Tampilan LINE developer console saat login} 
	\label{fig:line-developers-console-login} 
\end{figure}

\textit{Developer} perlu masuk ke LINE Developers console (https://developers.line.me/en/) dengan alamat email dan password dari akun LINE \textit{developer} (Gambar~\ref{fig:line-developers-console-login}). Jika \textit{developer} belum memiliki akun LINE, \textit{developer} perlu mengunduh aplikasi LINE untuk mendaftar akun LINE.

\item Langkah ke-2 : Mendaftar sebagai developer (\textit{developer})

\begin{figure}[H]
	\centering  
	\includegraphics[scale=0.4]{Gambar/line-developers-console-register-developer.png}  
	\caption[Tampilan LINE developer console saat register developer]{Tampilan LINE developer console saat register developer} 
	\label{fig:line-developers-console-register-developer} 
\end{figure}

Apabila \textit{developer} baru pertama kali masuk ke LINE Developers console, \textit{developer} perlu membuat akun developer (Gambar~\ref{fig:line-developers-console-register-developer}). \textit{Developer} hanya perlu mencantumkan nama dan alamat email untuk mendaftar.

\item Langkah ke-3 : Membuat provider baru

Provider adalah individu atau perusahaan yang menyediakan aplikasi yang akan dibuat. \textit{Developer} perlu mencantumkan nama provider untuk membuat provider baru. \textit{Developer} dapat menuliskan nama \textit{developer} sendiri atau nama perusahaan \textit{developer}.

\item Langkah ke-4 : Membuat channel
\begin{figure}[H]
	\centering  
	\includegraphics[scale=0.4]{Gambar/line-developers-console-create-channel.png}  
	\caption[Tampilan LINE developer console saat membuat channel]{Tampilan LINE developer console saat membuat channel} 
	\label{fig:line-developers-console-create-channel} 
\end{figure}

\textit{Developer} perlu memasukkan informasi yang dibutuhkan untuk membuat channel :
\begin{itemize}
\item Ikon aplikasi

Dokumen gambar untuk ikon aplikasi harus dibawah 3MB dengan ekstensi JPEG/PNG/GIF/BMP.

\item Nama aplikasi

Nama aplikasi tidak boleh lebih dari 20 karakter. Kata "LINE" tidak dapat digunakan sebagai nama aplikasi, walaupun kapitalisasinya tidak sama. Setelah dikonfirmasi, nama aplikasi tidak dapat diubah untuk tujuh hari ke depan.

\item Deskripsi aplikasi

Deskripsi aplikasi tidak boleh lebih dari 500 karakter.

\item Plan

Terdapat dua pilihan, Developer Trial dan Free. Plan Developer Trial memungkinkan \textit{developer} untuk membuat bot yang dapat mengirimkan push message dan memiliki 50 teman. Apabila \textit{developer} memilih plan ini, maka \textit{developer} tidak dapat melakukan upgrade atau membeli ID premium. Plan Free memungkinkan \textit{developer} untuk membuat bot dengan jumlah teman tak terbatas, namun \textit{developer} tidak dapat mengirimkan push message. \textit{Developer} dapat melakukan upgrade kapan saja dengan plan ini.

\item Kategori dan Subkategori

\textit{Developer} dapat memilih kategori dan subkategori yang cocok dengan aplikasi yang sedang dikembangkan.

\item Alamat email

Alamat email yang dicantumkan adalah alamat email yang akan menerima notifikasi dan pengumuman penting dari LINE. Maksimal karakter pada alamat email adalah 100 karakter.

\end{itemize}

\item Konfirmasi
\begin{figure}[H]
	\centering  
	\includegraphics[scale=0.4]{Gambar/line-developers-console-confirm-channel.png}  
	\caption[Tampilan LINE developer console saat konfirmasi pembuatan channel]{Tampilan LINE developer console saat konfirmasi pembuatan channel} 
	\label{fig:line-developers-console-confirm-channel} 
\end{figure}

Konfirmasi channel yang baru saja dibuat.

\end{enumerate}


\textbf{Membuat bot}

Setelah membangun channel, \textit{developer} perlu menyiapkan server untuk menjadi host dari bot. \textit{Developer} dapat menggunakan layanan cloud platform, seperti Heroku. Setelah itu, \textit{developer} dapat mulai mengatur bot pada console.

Aplikasi bot membutuhkan channel access token untuk membuat API call dan webhook URL untuk menerima webhook payload dari LINE Platform. Channel access token adalah long-lived token (token yang tidak memiliki kadaluarsa) yang harus diatur di dalam authorization header ketika membuat API call. \textit{Developer} dapat menerbitkan lagi channel access token kapanpun melalui console. Untuk menerbitkan channel access token, klik Issue pada "Channel settings" di halaman console. Sedangkan webhook URL adalah titik akhir dari server aplikasi bot dimana webhook payload dikirimkan.

Untuk mengatur webhook URL, \textit{developer} dapat memasukkannya ke halaman Channel settings pada console. Webhooks harus diaktifkan terlebih dahulu dengan menekan tombol enable webhooks. Untuk memeriksa apakah webhook URL dapat menerima event webhook, tekan tombol Verify dan pastikan hasilnya "Success". Webhook URL harus menggunakan HTTPS dan memiliki sertifikat SSL yang diterbitkan oleh certificate authority (CA) yang terotorisasi.

Setelah token dan webhook URL berhasil diset, tambahkan bot sebagai teman melalui akun LINE. \textit{Developer} dapat melakukannya dengan scan kode QR pada Channel Settings.

\textbf{Menkonfigurasi Keamanan}

\textit{Developer} dapat mengkonfigurasi keamanan tapi tidak wajib dilakukan. Untuk meningkatkan keamanan, \textit{developer} dapat mengatur server yang dapat memanggil API pada LINE Platform pada Security settings. \textit{Developer} dapat mendaftarkan alamat IP secara individual atau jika \textit{developer} memiliki server yang banyak \textit{developer} dapat menggunakan notasi classless inter-domain routing (CIDR) untuk mendaftarkan alamat jaringan.

\textbf{Alur kerja Messaging API}

Ketika user berinteraksi dengan bot seperti mengirimkan pesan atau menambah bot sebagai teman, LINE Platform mengirimkan HTTP POST request yang berisi webhook event object ke bot server yang disebutkan di kolom "Webhook URL" pada console. Request header berisi signature. 

Untuk mengecek apakah server dapat menerima webhook event, blok bot pada LINE dan cek server logs untuk menkorfimasi bahwa server dapat menerima unfollow event dari LINE Platform.

Untuk memastikan request yang dikirim berasal dari LINE Platform, bot server harus memvalidasi X-Line-Signature pada request header. Caranya dengan :
1. Menggunakan channel secret sebagai secret key, mengenerate Base64-encoded digest dari request body menggunakan algoritma HMAC-SHA256
2. Menkonfirmasi signature X-Line-Signature dalam request header cocok dengan digest.
 

\textbf{Webhook Event Object}

\begin{enumerate}
\item Khusus untuk one-on-one chat

\begin{itemize}
\item Message Event

Menunjukkan bahwa ada user yang mengirim pesan. Event ini dapat dibalas.

\item Follow Event

Menunjukkan bahwa akun bot ditambahkan sebagai teman (atau unblocked). Event ini dapat dibalas.

\item Unfollow Event

Menunjukkan bahwa akun bot diblok

\item Postback event

Menunjukkan user melakukan aksi postback. Event ini dapat dibalas.

\item Beacon event

Menunjukkan bahwa user telah masuk atau keluar dari jangkauan LINE Beacon. Event ini dapat dibalas.

\item Account link event 

Menunjukkan bahwa user telah melink akun LINE dengan akun layanan \textit{developer}. 

\end{itemize}

\item Group chats

\begin{itemize}
\item Message event

Menunjukkan bahwa ada user yang mengirim pesan. Event ini dapat dibalas.

\item Join event

Menunjukkan bot telah bergabung ke sebuah group chat

\item Leave event

Menunjukkan bot telah keluar dari sebuah group chat

\item Postback event

Menunjukkan user melakukan aksi postback. Event ini dapat dibalas.

\end{itemize}

\end{enumerate}

\textbf{Operasi pada bot}

\textit{Developer} dapat melakukan operasi berikut lewat bot :
\begin{enumerate}
\item Mengirim reply message

Reply message adalah pesan yang dikirim sebagai respons dari user-generated event. User-generated event adalah event yang muncul karena user berinteraksi dengan bot, misalnya mengirim pesan. \textit{Developer} hanya dapat membalas webhook events yang memiliki reply token.
Untuk membalas pesan, kirim HTTP POST request ke /bot/message/reply. Sertakan channel access token di dalam authorization header dan reply token di request body. \textit{Developer} dapat mengirimkan sampai 5 message object per request.

\item Mengirim push message

Untuk mengirim push message, \textit{developer} harus memerhatikan plan yang dipakai. Apabila \textit{developer} memakai plan Free maka \textit{developer} tidak dapat melakukan operasi ini. Push message adalah pesan yang dapat bot kirimkan ke user kapanpun. Push message tidak membutuhkan reply token seperti saat mengirim reply message. Ketika mengirim push message, sebutkan user ID di dalam property to. ID penerima dapat ditemukan dari webhook event object. Apabila penerima hanya satu, kirimkan request ke /bot/message/push. Sedangkan apabila penerima ada beberapa, kirimkan ke /bot/message/multicast. \textit{Developer} dapat mengirimkan sampai 5 message object per request.

\item Mendapatkan konten yang dikirim oleh user

Untuk mengambil gambar, video, atau audio yang dikirim user, kirimkan HTTP GET request ke /bot/message/{messageId}/content. Konten yang dikirim oleh user otomatis dihapus dalam jangka waktu tertentu.

\item Mendapatkan informasi user profile

Untuk mendapatkan informasi user profile dari user yang menambahkan bot atau mengirim pesan ke bot, kirimkan HTTP GET request ke /bot/profile/{userId}. Request ini akan mengembalikan display name, user ID, profile image URL, dan status message (jika tersedia) dari user.
\end{enumerate}

\textbf{LINE@ Manager}

LINE@ Manager adalah alat untuk mengatur akun LINE@ (LINE bot). \textit{Developer} dapat meningkatkan user experience dengan mengatur halaman akun, membuat Timeline post, dan menggunakan fitur lain yang disediakan LINE@ Manager. Berikut adalah hal-hal yang bisa dilakukan :
\begin{enumerate}
\item Mengubah tampilan halaman akun

\textit{Developer} dapat mengubah gambar cover, logo, tombol, dan informasi yang disediakan

\item Mengatur greeting message

Jika \textit{developer} mengaktifkan Greeting message pada Channel settings, maka \textit{developer} dapat mengatur greeting message yang akan dikirim ke user saat pertama kali menambahkan bot sebagai teman. \textit{Developer} dapat melakukannya juga dengan program melalui follow webhook event.

\item Mengatur auto reply message

Jika \textit{developer} mengaktifkan "Auto reply message" pada Channel settings, maka \textit{developer} dapat mengatur pesan balasan otomatis setiap user mengirimkan pesan ke bot.
\end{enumerate}
	
	\end{enumerate}
		
	\item \textbf{Memodifikasi BlueTape sehingga dapat berjalan di Heroku menggunakan PostgreSQL}\\
	{\bf Status :} Ada sejak rencana kerja skripsi.\\
	{\bf Hasil :} BlueTape sudah dapat berjalan di Heroku. Situs BlueTape untuk skripsi ini diberi nama shadowtape dan dapat diakses melalui situs \url{https://shadowtape.herokuapp.com}. Basis data BlueTape versi skripsi ini telah dikonversi dari berbasis MySQL ke PostgreSQL. Proses modifikasi BlueTape dilakukan dengan :
	\begin{itemize}
		\item Menambah dokumen Procfile yang isinya :"web:vendor/bin/heroku-php-apache2 www/" pada direktori \texttt{root}
		\item Menambahkan 1 baris kode berikut pada dokumen config.php pada direktori www/application/config : 
		\begin{lstlisting}
		
		$ config['sess_save_path] = sys_get_temp_dir();
		
		\end{lstlisting}
		Kode tersebut untuk mengatasi error yang timbul karena session tidak berhasil menulis ke \textit{filesystem}. 
		\item Mengganti fungsi replace pada dokumen migration dengan insert dan update. Contoh :
		\begin{lstlisting}
$this->db->replace('Bluetape_Userinfo', array(
            'email' => $email,
            'name' => $name,
            'lastUpdate' => strftime('%Y-%m-%d %H:%M:%S')
        ));
\end{lstlisting}
(line 77-81 Auth\_Model.php)
menjadi :
\begin{lstlisting}
$PKconfirmation = $this->db->get_where('Bluetape_Userinfo', array(
			'email' => $email
		));
		if($PKconfirmation == null ){
			$this->db->insert('Bluetape_Userinfo', array(
				'email' => $email,
				'name' => $name,
				'lastUpdate' => strftime('%Y-%m-%d %H:%M:%S')
			));
		}
		else{
			$this->db->where('email', $email);
			$this->db->update('Bluetape_Userinfo', array(
				'name' => $name,
				'lastUpdate' => strftime('%Y-%m-%d %H:%M:%S')
			));
		}
\end{lstlisting}

		\item Mengubah tipe data \texttt{datetime} menjadi \texttt{timestamp}
		\item Membungkus nama tabel atau kolom yang aturan penamaannya menggunakan \textit{camel case} dengan tanda kutip dua
	\end{itemize}
		
	\item \textbf{Memodifikasi BlueTape sehingga dapat menangkap email yang masuk ke email khusus}\\
	{\bf Status :} Ada sejak rencana kerja skripsi.\\
	{\bf Hasil :} BlueTape dapat menangkap email yang masuk ke email khusus. Namun, masih terdapat error apabila email yang teridentifikasi sebagai email pengumuman memiliki lampiran. Modifikasi yang dilakukan untuk BlueTape adalah membuat email baru khusus untuk menangkap pengumuman, menambah model, view, dan controller dari modul Pengumuman, menambahkan dokumen migration untuk membuat tabel Pengumuman, dan menambah Cron. Cara kerja penangkap email khusus adalah sebagai berikut :
	\begin{itemize}
		\item Email masuk ke email khusus untuk menangkap pengumuman, yaitu \texttt{shadowbluetape@gmail.com}
		\item Menjalankan secara manual Cron dengan mengunjungi : http://shadowtape.herokuapp.com/Cron/daily
		\item Cron akan mengaktifkan pengecekan email baru yang belum terbaca
		\item Apabila ada email baru, maka akan dilakukan pengecekan status pengirim sah atau tidak
		\item Apabila sah, informasi email akan dimasukkan ke tabel \texttt{Pengumuman}
		\item Email yang baru masuk ke tabel dapat langsung dilihat melalui menu Pengumuman di BlueTape
	\end{itemize}
	
		
	\item \textbf{Memodifikasi BlueTape sehingga dapat melakukan push notification ke akun LINE@}\\
	{\bf Status :} Ada sejak rencana kerja skripsi.\\
	{\bf Hasil :} BlueTape belum bisa melakukan push notification ke akun LINE@.
		
	\item \textbf{Melakukan pengujian}\\
	{\bf Status :} Ada sejak rencana kerja skripsi.\\
	{\bf Hasil :} Belum dilakukan. Langkah ini akan dilakukan setelah fitur selesai dibuat. 
		
	\item \textbf{Menulis dokumen skripsi}\\
	{\bf Status :} Ada sejak rencana kerja skripsi.\\
	{\bf Hasil :} Bab 1 telah selesai ditulis. Bab 1 berisi latar belakang, rumusan masalah, tujuan, batasan masalah, metodologi, dan sistematika penulisan. Bab 2 telah selesai ditulis. Bab 2 berisi dasar teori tentang BlueTape, Heroku, Gmail, PHP IMAP, dan LINE. Bab 3 telah ditulis sebagian. Bagian yang telah ditulis di bab 3 adalah analisis BlueTape, dan analisis Heroku.
\end{enumerate}

\section{Pencapaian Rencana Kerja}
Langkah-langkah kerja yang berhasil diselesaikan dalam Skripsi 1 ini adalah sebagai berikut:
\begin{enumerate}
\item Melakukan studi literatur tentang Heroku, Gmail, PHP IMAP, dan LINE
\item Memodifikasi BlueTape sehingga dapat menangkap email yang masuk ke email khusus
\item Menulis bab1, bab2, dan sebagian bab3 pada dokumen skripsi
\end{enumerate}


\section{Kendala yang Dihadapi}
%TULISKAN BAGIAN INI JIKA DOKUMEN ANDA TIPE A ATAU C
Kendala - kendala yang dihadapi selama mengerjakan skripsi :
\begin{itemize}
	\item Pembagian waktu untuk magang di perpustakaan, kerja di DNArtworks, kerja praktek dengan Catholicer, mengerjakan tugas-tugas dari kuliah biasa, dan mengerjakan skripsi.
	\item Kendala pada laptop yang tidak dapat menanggung beban berat, sehingga harus pintar-pintar mengelola apa yang harus dibuka dan sabar apabila respon lama.
	\item Selama mengerjakan skripsi, daya tahan tubuh menurun sehingga mudah terserang penyakit.
\end{itemize}

\vspace{1cm}
\centering Bandung, \tanggal\\
\vspace{2cm} \nama \\ 
\vspace{1cm}

Menyetujui, \\
\ifdefstring{\jumpemb}{2}{
\vspace{1.5cm}
\begin{centering} Menyetujui,\\ \end{centering} \vspace{0.75cm}
\begin{minipage}[b]{0.45\linewidth}
% \centering Bandung, \makebox[0.5cm]{\hrulefill}/\makebox[0.5cm]{\hrulefill}/2013 \\
\vspace{2cm} Nama: \pembA \\ Pembimbing Utama
\end{minipage} \hspace{0.5cm}
\begin{minipage}[b]{0.45\linewidth}
% \centering Bandung, \makebox[0.5cm]{\hrulefill}/\makebox[0.5cm]{\hrulefill}/2013\\
\vspace{2cm} Nama: \pemB \\ Pembimbing Pendamping
\end{minipage}
\vspace{0.5cm}
}{
% \centering Bandung, \makebox[0.5cm]{\hrulefill}/\makebox[0.5cm]{\hrulefill}/2013\\
\vspace{2cm} Nama: \pembA \\ Pembimbing Tunggal
}
\end{document}

